Binck OpenApi documentation
===========
This document describes how an application can get access to customers data, send orders to the market and retrieve streaming quotes, order events and news.

## Logon to Binck API using OAuth2

The Binck API is accesible with a rest API protected with OAuth2.
> “The authorization code grant is used when an application exchanges an authorization code for an access token. After the user returns to the application via the redirect URL, the application will get the authorization code from the URL and use it to request an access token. This request will be made to the token endpoint.”

More info: https://www.oauth.com/oauth2-servers/access-tokens/authorization-code-request/

Prerequisites:
- An application id with secret, realm, scope(s) and redirect URL, supplied by Binck.

Binck has a test environment, called sandbox, and a production environment. Both have an authentication provider and an API endpoint.
The authentication provider uses the OAuth2 "authorization code" flow.\
For this example we use the sandbox environment, with predefined test users and passwords.

### Step 1: Login
Create a 'Log in' link sending the user to:

https://login.sandbox.binck.com/am/oauth2/realms/{realm}/authorize?ui_locales={it}&client_id={CLIENT_ID}&scope={read}&state={1234zyx}&response_type={code}&redirect_uri={REDIRECT_URI}

**realm** – The bincknlapi realm is used for the Dutch Binck customers\
**ui_locales** - The language to be used for the login pages, examples: fr, it, or nlBE\
**scope** - One or more scope values (separated by space), indicating which parts of the user's account you wish to access, examples are read, write, news, quotes\
**state** - A random string generated by your application, which you'll verify later\
**code** - Indicates that your server expects to receive an authorization code\
**client_id** - The client ID you received when you first created the application\
**redirect_uri** - Indicates the URI to return the user to after authorization is complete

The user sees the login dialog:
TODO Add login dialog screenshot

Skipping entering the validation code (SMS challenge) results in a readonly session. Placing orders won’t be allowed, even if the application requested 'write' scope.

### Step 2: Retrieve authorization code
After logging in, the user sees a dialog to give access to the thirdparty, if access is not already granted. In order to authorize, the user must login with the validation code (2FA).

TODO Add consent page screenshot

If the user allows access, the service redirects the user back to your site (the _redirect_uri_) with an auth code in the query string.

[https://{REDIRECT_URI}/?code={AUTH_CODE_HERE}&scope={read}&state={1234zyx}](https://{REDIRECT_URI}/?code={AUTH_CODE_HERE}&scope={read}&state={1234zyx})

**code** - The server returns the authorization code in the query string\
**state** - The server returns the same state value that you passed

You should first compare this state value to ensure it matches the one you started with. You can typically store the state value in a cookie, and compare it when the user comes back. This ensures your redirection endpoint isn't able to be tricked into attempting to exchange arbitrary authorization codes.

#### Error logging in
If the login failed, the error is returned in the query string.

[https://{REDIRECT_URI}/?error_description=Resource%20Owner%20did%20not%20authorize%20the%20request&state={1234xyz}&error=access_denied](%20https:/REDIRECT_URI/?error_description=Resource%20Owner%20did%20not%20authorize%20the%20request&state=1234xyz&error=access_denied)

This is an example of the error when the user denied access for your application.

### Step 3: Retrieve token
With the code the application can request the token.

`POST` https://login.sandbox.binck.com/am/oauth2/realms/{realm}/access_token \
`grant_type=authorization_code`\
`client_id=CLIENT_ID`\
`client_secret=CLIENT_SECRET`\
`redirect_uri=REDIRECT_URI`\
`code=AUTH_CODE_HERE`

The request requires a header "Content-type: application/x-www-form-urlencoded".

**realm** - The realm to identify the customer group, for example binckitapi\
**grant_type** - The grant type for this flow is authorization_code\
**client_id** - The client ID you received when you first created the application\
**client_secret** - The password of this client\
**redirect_uri** - Must be identical to the redirect URI provided in the original link\
**code** - This is the code you received in the query string

Because this request contains your secret, it cannot be done in javascript, or any other client side application.

The response will contain:
```javascript
{
    "access_token": "5af56faa-8cd9-466b-81b1-5f2eadafca1f",
    "refresh_token": "dcdd4c1e-4241-405f-ae1c-2dc14e31d895",
    "scope": "read write quotes news",
    "token_type": "Bearer",
    "expires_in": 3599
}
```
**access_token** – The token to be used when calling the API\
**expires_in** - The time in seconds the token will be valid\
**refresh_token** – The token used to request a new access_token, just before token expiry\
**scope** – The requested scope, for example “read write”\
**token_type** – You retrieved a Bearer token

The expiry time is one hour. However, if there are no requests in 30 minutes, the session will expire as well (idle time = 30 minutes).

#### Error retrieving code
If there is a problem receiving the code, an error will be returned. If there is no problem with the connection, the auth server responds with an error object in this format:

```javascript
{
    "error_description": "Client authentication failed",
    "error": "invalid_client"
}
```
### Step 4: First API request
The token grants access to the API. For example, to get the accounts of the user.

Before proceeding, the API connection can be tested without token, by using the version endpoint.

https://api.sandbox.binck.com/api/v1/version

This GET request returns, if directly requested, a json response with the build date and version of the API.

`GET` https://api.sandbox.binck.com/api/v1/version

```javascript
{
    "Accept": "application/json; charset=utf-8",
    "Authorization": "Bearer ", +  ACCESS_TOKEN
}
```

**access_token** - The token retrieved in step 3

Endpoint:
https://api.sandbox.binck.com/api/v1/accounts

The request is granted access if the token is supplied.

The complete API description can be found at https://developers.binck.com.

#### Error getting data

The errors are returned in a uniform layout.
```javascript
{
    "developerMessage": "Unauthorized",
    "endUserMessage": "Non sei autorizzato.",
    "errorCode": "Unauthorized",
    "errorId": "unknown"
}
```

**developerMessage** – A notification for the developer of the app. Not meant to be shown to end users\
**endUserMessage** – A translated error, in the language of the end user, to show to the end user\
**errorCode** – A code, which can be used for development\
**errorId** – If applicable, an error id to report back to Binck, for trouble shooting

### Step 5: Refresh token
The token request contains an expiration time. After this time, the token is no longer valid.
So, before the token expires, a new token must be requested. For this, we have a refresh token.

`POST` https://login.sandbox.binck.com/am/oauth2/realms/{realm}/access_token \
`grant_type=refresh_token`\
`client_id=CLIENT_ID`\
`client_secret=CLIENT_SECRET`\
`refresh_token=REFRESH_TOKEN_HERE`

**realm** - The realm to identify the customer group, for example binckitapi\
**grant_type** - The grant type to refresh a token is refresh_token\
**client_id** - The client ID you received when you first created the application\
**client_secret** - The password of this client\
**refresh_token** – The token received when requesting the initial token

As with the initial token retrieval, this request is not allowed from any client application hosted on the customers machine.

The response is the same as the initial token request. See step 3.

### Step 6: Production
The production environment is the same as sandbox, but, with real customers and live data.

Use these URL’s:
https://login.binck.com/am/oauth2/
https://api.binck.com/api/v1/

#### Releases
If there is a release and there is a need to set the Binck backend in maintenance, this error message is returned for every request:

```javascript
{
    "DeveloperMessage": "Temporary maintenance mode",
    "EndUserMessage": "BinckBank is currently down for planned maintenance. We expect to be back in a couple of hours. Thanks for your patience.",
    "ErrorCode": "ServiceUnavailable",
    "ErrorId": 503
}
```

Your application must be able to handle this error message.

#### Documentation
The description of the available endpoints is located here: https://developers.binck.com, and an example of a client written in javascript can be found here: https://github.com/binckbank-api/showcase-js/

### Things to keep in mind developing the API
1.  Never ever leak the secret. Don’t put in in frontend code.
2.  The secret will change periodically, keep it in a controlled environment.
3.  The customer login is on person level. This means if a customer has more than one account, the customer might need to select the account to use for the application. There are multiple account types, not all account types have trading options (example is the savings account).
4.  Request small portions of data, using paging. If you must display 10 transactions, request ten transactions.
5.  When placing an order, comply with the rules. Show the KID document if available, give an option to display ex ante costs.
6.  Be prepared for error messages. Never display the developer message, but your own one. Developer messages are for logging and trouble shooting.
7.  End user messages must be shown, they are in the locale language of the customer.
8.  When the systems of Binck are down, the error message is stating this. Sign in page shows a maintenance page.
9.  When requesting the login page, supply the locale of the customer. If not, the fallback might not be the desired language of the country.
10.  Instrument ids might change overnight. When caching, keep this in mind.


